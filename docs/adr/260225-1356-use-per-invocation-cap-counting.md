# ADR-260225-1356: use-per-invocation-cap-counting

## Created At

2026-02-25 13:56 KST

## Status

Confirmed

## Context

DEV-023에서 `tools/llm_client.py`의 일일 호출 상한(`LLM_DAILY_CAP`)을 SQLite로 영속화할 때, "호출 1회"를 어떤 단위로 계산할지 명시가 필요했다.
`.specs/ai_agent_spec.md`의 LLM 호출 정책은 429 재시도(2s -> 4s -> 8s)와 일일 상한(기본 30회/day)을 요구하지만, 재시도 요청까지 상한 카운트에 포함할지에 대한 계산 단위는 고정돼 있지 않다.
재시도까지 모두 카운트하면 동일한 논리 호출이 일시적 429/5xx에 의해 상한을 과도하게 소모해 디그레이드 모드로 조기 전환될 수 있다.

## Decision

LLM 일일 상한 카운트는 HTTP 재시도 횟수가 아니라 상위 `invoke_llm` 논리 호출 1회를 기준으로 증가시키도록 결정한다.

## Rationale

검토한 대안은 다음과 같다.

- 대안 A: HTTP 시도(재시도 포함)마다 카운트한다.
  - 장점: 네트워크 호출 총량을 보수적으로 제한할 수 있다.
  - 단점: 429/일시 장애 시 상한이 급격히 소모되어 정상적인 장애 처리 흐름(analyze/triage/postmortem)이 조기 차단될 수 있다.

- 대안 B: 성공 응답일 때만 카운트한다.
  - 장점: 실제 토큰 사용과 유사한 방향으로 카운트할 수 있다.
  - 단점: 실패 루프가 길어져도 상한 억제 신호가 늦게 발생해 보호 장치로서 일관성이 약해질 수 있다.

- 대안 C(채택): 논리 호출 단위(`invoke_llm` 1회)로 카운트하고, 내부 재시도는 동일 호출의 일부로 본다.
  - 장점: 상한의 의미(업무 단계 단위 호출 제어)와 재시도 정책(일시 장애 완화)을 분리해 운영 해석이 단순하다.
  - 장점: 일시적 실패가 디그레이드 모드 진입 시점을 과도하게 앞당기지 않는다.
  - 트레이드오프: 실제 HTTP 시도 수와 카운트가 일치하지 않으므로 관측/리포트에서는 시도 수를 별도 지표로 분리해야 한다.
