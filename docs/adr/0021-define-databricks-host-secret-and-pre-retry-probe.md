# ADR-0021: define-databricks-host-secret-and-pre-retry-probe

## Created At

2026-02-25 01:06 KST

## Status

PendingReview

## Context

DEV-033 구현에서 Databricks Jobs API 호출 경로를 안정화해야 했고, 특히 `run-now` 요청이 timeout 또는 5xx로 실패했을 때 실제로 원격 실행이 시작되었는지 알 수 없는 상태를 줄여야 했다. 이 시점에서 동일 요청을 즉시 재시도하면 같은 잡이 중복 실행될 수 있어 운영 비용과 데이터 일관성 측면의 리스크가 생긴다. 또한 Databricks API base host 값은 환경별로 달라지고, 기존 시크릿 관리 흐름과 일관되게 다뤄야 운영 절차와 회전(로테이션) 정책을 유지할 수 있다.

## Decision

Databricks API base host는 `get_secret("databricks-host")`로 조회하고, `run-now` 요청이 timeout 또는 5xx를 반환하면 재시도 전에 `runs/list(active_only)`로 기존 실행 여부를 먼저 확인하는 방식으로 결정한다.

## Rationale

이 결정은 중복 실행 방지와 운영 일관성을 동시에 확보하기 위한 절충안이다. host를 시크릿에서 읽으면 기존 비밀값 관리 체계(권한 분리, 교체 절차, 감사 흔적)와 맞물려 환경별 설정 편차를 줄일 수 있고, 재시도 전 active run 조회를 넣으면 네트워크/일시 장애 구간에서 발생하는 "이미 실행되었지만 응답만 잃어버린" 상황의 중복 실행 가능성을 낮출 수 있다.

대안 1은 `DATABRICKS_HOST` 환경변수를 직접 읽는 방식이었다. 장점은 구현이 단순하고 런타임 의존성이 적다는 점이지만, 환경 주입 누락 시 장애 형태가 즉시 드러나지 않거나 배포 단위마다 설정 불일치가 발생하기 쉬웠다. 또한 본 작업 범위에서는 host를 다른 민감 설정과 동일한 채널에서 관리하는 편이 운영 표준과 더 일치하므로 기각했다.

대안 2는 timeout/5xx 이후 곧바로 재시도하거나 `run_id` 기반 `check_job_status`를 직접 호출하는 방식이었다. 즉시 재시도는 구현은 쉽지만, 첫 요청의 실제 처리 여부를 모르는 상태에서 중복 실행 위험을 수용해야 한다는 단점이 컸다. `run_id` 기반 상태 조회는 run_id를 확보한 성공 응답이 있는 경우에는 유효하지만, timeout/5xx 구간에서는 run_id 자체가 없을 수 있어 판단 근거로 사용하기 어렵다. 따라서 재시도 직전에 `runs/list(active_only)`로 현재 활성 실행을 탐지하는 방법이 실패 모드 대응 범위를 더 넓게 커버한다고 판단해 이 대안을 기각했다.

대안 3은 별도 idempotency key 저장소를 두고 요청 중복을 애플리케이션 레벨에서 차단하는 방식이었다. 이 접근은 이론적으로 가장 엄격하지만, DEV-033의 저영향 의사결정 범위를 넘어 추가 저장소 설계, 키 수명 관리, 장애 복구 절차가 필요해 복잡도가 과도하게 증가한다. 현재 요구사항 대비 비용이 커서 이번 결정에서는 제외했다.
