## 1. 개요

### 목적

사람은 **설계와 판단**에 집중하고, AI 에이전트 시스템이 **실행과 검증**을 담당하는
개발 워크플로를 구축한다.

### 기존 방식의 한계

바이브 AI 코딩은 빠른 프로토타이핑에는 유용하지만, 프로젝트가 커질수록 다음과 같은 구조적 문제가 드러난다.

- **맥락 유실과 재현성의 부재** — 대화 기반 작업은 히스토리가 흩어지고, 왜 그렇게 결정했는지 추적할 수 없다. 같은 결과를 다시 만들어내기도 어렵다.
- **자기 검증의 구조적 한계** — 코드를 작성한 모델이 같은 맥락에서 스스로 리뷰하면, 자기 변호에 빠지기 쉽다. 독립적인 검증 단계가 없으면 오류가 그대로 통과된다.
- **사람이 병목이 되는 마이크로매니징** — 매 단계마다 사람이 직접 지시하고 확인해야 하므로, 인지 부하가 급격히 늘어난다. 스스로 정한 작업 루틴조차 빼먹는 휴먼 에러가 생기고, 결국 사람이 전체 흐름의 병목 지점이 된다.

### 이 아키텍처가 해결하는 방법

각 문제는 아키텍처의 특정 레이어에서 해결된다.

| 문제 | 해결 레이어 | 해결 방법 |
|---|---|---|
| 맥락 유실·재현성 부재 | 플랫폼 제어 평면 | Sudocode로 이슈 상태를 추적하고, ADR로 의사결정 이유를 기록 |
| 자기 검증의 구조적 한계 | 2차 레이어 (Subagents) | 구현과 리뷰를 다른 에이전트 인스턴스에 분리해 독립적으로 검증 |
| 마이크로매니징 병목 | 1차 레이어 (Skills) | SKILL.md 절차서가 매 단계 사람의 지시를 대체 |

### 아키텍처 개요

이 시스템은 **두 평면**으로 구성된다.

```
플랫폼 제어 평면 (코드)          인지 오케스트레이션 평면 (마크다운)
────────────────────────        ──────────────────────────────────
OpenCode가 세션을 소유            1차 레이어 (Skills 패턴)
Sudocode가 상태를 관리            └─ 조정자가 SKILL.md 로드 → 판단·실행
IDE가 관측·개입 창구 제공         2차 레이어 (Subagents 패턴)
                                  └─ 조정자가 서브에이전트 파견 → 독립 검증
```

**플랫폼 제어 평면**은 에이전트 세션 관리, 상태 추적, 관측을 코드로 처리한다. OpenCode가 이 평면을 소유한다. 사람이 따로 Gateway를 만들 필요가 없다.

**인지 오케스트레이션 평면**은 에이전트가 무엇을 언제 어떻게 할지를 마크다운 문서(SKILL.md)로 정의한다. 코드를 수정하지 않고 텍스트 파일만 고쳐도 에이전트의 행동이 바뀐다.

1차와 2차 레이어의 결합을 **Deep Agents 패턴**이라 부른다 (LangChain의 에이전트 분류 방법을 따름).

### 워크플로 요약

이 문서가 제안하는 워크플로는 5단계 파이프라인으로 구성된다.

1. **Spec 작성** — 사람이 요구사항과 설계 의도를 문서로 정의한다.
2. **Roadmap 분해** — Spec을 기반으로 실행 가능한 태스크 단위로 쪼갠다. 어떤 순서로 무엇부터 할지는 Sudocode가 알아서 정리한다.
3. **자동 실행** — AI 에이전트 팀이 구현과 검증을 자동으로 수행한다.
4. **아키텍처 결정 기록 (ADR)** — 에이전트가 스펙에 명시되지 않은 판단을 내릴 때마다 그 이유를 문서로 남긴다. 나중에 왜 그렇게 했는지 추적할 수 있다.
5. **사람 리뷰** — 사람은 결과물만 확인하고, 승인 또는 피드백을 준다.
6. **반복** — 승인 후 머지되면 에이전트가 자동으로 다음 이슈를 집어 3번으로 돌아간다.

### 기대 효과 및 이점

업무 체계를 갖춘 에이전트 시스템으로 전환하면 다음과 같은 이점이 있다.

- **사람은 설계와 판단에 집중** — 반복적인 실행 작업을 AI에 위임하여, 사람은 가장 가치 있는 의사결정에만 시간을 쓴다.
- **독립적 검증으로 품질 확보** — 작성과 리뷰를 분리하고 자동 루프를 통해 사람 손을 타기 전에 신뢰성을 확보한다.
- **모든 결정이 추적 가능** — 설계 의도는 Spec에, 실행 이력은 Issue에, 중간 판단은 ADR에 남아 누구든 맥락을 따라갈 수 있다.

### 사람의 역할 (3가지만)

1. **Spec 작성**: 도메인 요구사항, 스키마, 설계 의도 정의
2. **Roadmap 관리**: 태스크 분해, 우선순위, 의존성 정의
3. **PR 리뷰**: AI가 만든 결과물의 품질 판단

나머지(태스크 선택, 실행 순서 결정, Issue 생성, 브랜치, 구현, 테스트, 상태 추적)는 자동화한다.

## 2. 사용 도구

도구는 아키텍처 평면에 따라 두 그룹으로 나뉜다.

### 플랫폼 제어 평면 (코드가 소유)

이 레이어는 코드로 구현된다. 에이전트가 실행되는 환경 자체를 제어한다.

#### OpenCode / Claude Code

에이전트가 실행되는 플랫폼이다. 터미널 세션을 소유하고, 사용자와 직접 대화하며, 도구를 호출한다. 이 플랫폼이 채널을 소유하기 때문에 별도의 Gateway 코드를 만들 필요가 없다.

- **UI 관측·개입** — 데스크톱 앱에서 에이전트가 무엇을 하는지 실시간으로 확인하고 개입할 수 있다. 서브에이전트의 작업도 같은 UI에서 보인다

#### Sudocode MCP

이슈 단위로 작업 상태를 관리하는 서버다. 에이전트와 사람이 같은 이슈 목록을 공유한다.

- 이슈 상태 전환: `open` → `in_progress` → `needs_review` → `closed`
- 이슈 간 의존성 그래프 — 어떤 작업이 다른 작업을 막고 있는지 추적
- 에이전트가 MCP 도구를 호출해 상태를 읽고 쓴다

이와 같은 프로젝트 상태 관리 기능을 통해 병렬 에이전트 오케스트레이션을 더 적은 인지 부하로 할 수 있다.

#### IDE (VSCode / OpenCode 데스크톱)

에이전트가 진행 중인 작업을 사람이 들여다볼 수 있는 창구다. 서브에이전트가 무엇을 하는지, 어느 단계까지 왔는지 실시간으로 확인하고 개입할 수 있다.

---

### 인지 오케스트레이션 평면 (마크다운이 소유)

이 레이어는 코드가 아니라 SKILL.md 파일로 정의된다. 에이전트가 무엇을 언제 어떻게 할지는 마크다운을 읽고 스스로 판단한다.

#### Superpowers 스킬 (시스템 공통)

여러 프로젝트에서 공통으로 쓸 수 있는 시스템 수준 스킬 모음이다. 2차 레이어(Subagents 패턴)를 실행하는 핵심 스킬이 여기 있다.

- **git worktree 격리** — 작업별로 독립된 작업 디렉토리를 만들어 브랜치 간 충돌을 방지한다
- **서브에이전트 파견** — 구현과 리뷰를 별도 에이전트 인스턴스에 위임해 맥락 오염을 막는다
- **리뷰 루프** — 스펙 준수 리뷰 → 코드 품질 리뷰 → 문제 발견 시 재작업 → 재리뷰 반복

#### 사용자 정의 스킬 (프로젝트별)

프로젝트 고유의 워크플로우를 정의하는 마크다운 절차서다. 에이전트가 이 파일을 읽고 1차 레이어(Skills 패턴)를 실행한다.

없으면 무슨 일이 생기는가 — 에이전트가 매번 사람에게 "다음에 뭘 해야 하나요?" 물어봐야 한다.

스킬 파일에 담기는 것:
- 언제 이 스킬을 시작하는가 (트리거 조건)
- 어떤 순서로 무엇을 하는가 (단계별 절차)
- 어떤 조건이 충족돼야 다음으로 넘어갈 수 있는가 (비협상 제약조건)
- 예외 상황이 발생하면 어떻게 처리하는가

예시 스킬: 이슈 실행(`run-one`), 승인·머지(`approve`), 아키텍처 결정 문서화(`create-adr`)

#### ADR 시스템

에이전트가 스펙에 명시되지 않은 중요한 판단을 내릴 때 그 이유를 기록하는 문서 체계다. 코드가 아니라 마크다운으로 작성된다.

없으면 무슨 일이 생기는가 — 나중에 "왜 그렇게 했는가"를 알 수 없다. 같은 결정을 두 번 고민하게 된다.

#### API 키 (Claude, GPT 등)

에이전트가 언어 모델을 호출하기 위한 인증 정보다. OpenCode 설정 파일에서 관리한다.

## 3. 워크플로우

### 오케스트레이션 구조

에이전트의 행동을 코드로 하드코딩하지 않는다. 대신 SKILL.md라는 마크다운 절차서로 정의하고, 에이전트가 이 파일을 읽고 스스로 판단해 실행한다.

**1차 레이어 (Skills 패턴)** — 조정자 에이전트가 SKILL.md를 온디맨드로 로드해 워크플로 전체를 실행한다. 사람이 `/run-one`을 호출하면 조정자가 이슈 선택부터 검증 완료까지 스스로 처리한다.

**2차 레이어 (Subagents 패턴)** — 조정자는 구현과 리뷰를 직접 하지 않는다. 신선한 컨텍스트의 서브에이전트에 위임한다. 구현한 에이전트와 리뷰하는 에이전트가 분리되기 때문에 자기검증 편향이 사라진다.

두 레이어의 결합이 이 시스템의 핵심이다.

### 다이어그램

```
══ 플랫폼 제어 평면 (OpenCode + Sudocode) ════════════════
  이슈 상태: open → in_progress → needs_review → closed
  에이전트 세션·관측·개입: OpenCode UI
══════════════════════════════════════════════════════════

[사람] Spec 작성
  ↓
[사람] Roadmap 분해 → Sudocode 이슈 등록
  ↓
── 1차 레이어 (Skills) ──────────────────────────────────
  [조정자] /run-one SKILL.md 로드
    ├─ 이슈 선택 (우선순위 순, 가장 작은 번호)
    ├─ git worktree로 작업 디렉토리 격리
    ├─ 이슈 상태 → in_progress
    │
── 2차 레이어 (Subagents) ───────────────────────────────
    │  ├─ [서브에이전트] 구현
    │  ├─ [서브에이전트] 스펙 준수 리뷰
    │  ├─ [서브에이전트] 코드 품질 리뷰
    │  │   └─ (문제 발견 시 재작업 → 재리뷰)
─────────────────────────────────────────────────────────
    │
    ├─ (결정이 필요한 경우)
    │   ├─ ADR 작성 → docs/adr/에 저장
    │   └─ 후속 이슈 생성 → Sudocode에 등록
    └─ 이슈 상태 → needs_review
  ↓
[사람] 로컬 리뷰 (OpenCode UI에서 관측·확인)
  ↓
[사람] /approve SKILL.md → 머지 → 이슈 종결
  ↓
[에이전트] 다음 이슈로 반복
```

### 워크플로우 상세

#### 1단계: Spec 작성 (사람)

에이전트가 "왜 이걸 만드는가"를 알 수 있어야 올바른 판단을 내릴 수 있다.

Spec에는 이런 내용이 담긴다:
- 도메인 요구사항과 제약조건
- 데이터 스키마나 인터페이스 정의
- 설계 의도 — 무엇을 원하는지보다 **왜** 그것을 원하는지

Spec이 없으면 에이전트는 판단 근거 없이 작업한다. 결과물이 의도와 달라도 알 방법이 없다.

#### 2단계: Roadmap 분해 (사람)

Spec을 에이전트가 실행 가능한 단위로 쪼갠다. 각 이슈는 한 번의 작업 세션으로 끝낼 수 있는 범위다.

Sudocode가 이슈 간 의존성을 관리한다. A가 완료돼야 B를 시작할 수 있는 관계를 설정하면, 에이전트가 순서를 알아서 지킨다.

#### 3단계: 자동 실행 (에이전트, 1차 + 2차 레이어)

`/run-one` 스킬 하나로 이슈 하나의 전체 라이프사이클을 처리한다.

**1차 레이어(Skills)에서 조정자가 하는 것:**
- 준비된 이슈 중 하나를 선택
- git worktree를 만들어 메인 브랜치와 격리
- 스펙에 없는 중요한 결정을 내려야 할 때 ADR 작성

**2차 레이어(Subagents)에서 서브에이전트가 하는 것:**
- 구현 서브에이전트: 코드 작성
- 스펙 준수 리뷰 서브에이전트: 의도와 맞게 구현됐는지 독립 검증
- 코드 품질 리뷰 서브에이전트: 코드 자체의 완성도 검토

조정자는 직접 코드를 작성하지 않는다. 위임하고, 결과를 받아 다음 단계를 결정한다.

#### 4단계: 로컬 리뷰 (사람)

에이전트가 이미 독립 검증 루프를 거쳤다. 사람은 OpenCode UI에서 전체 흐름을 확인하고, 결과물이 의도에 맞는지만 판단하면 된다.

사람이 확인해야 하는 것:
- 결과물이 Spec의 의도에 맞는가
- 에이전트가 기록한 ADR이 납득 가능한가

#### 5단계: 승인 (사람)

`/approve` 스킬이 머지부터 정리까지 자동으로 처리한다. 사람은 명령 한 번으로 끝낸다.

