## 1. 개요

### 목적

> *"엔지니어의 역할은 코드를 작성하는 것에서 환경을 설계하고, 의도를 명세하고, 구조화된 피드백을 제공하는 것으로 이동한다."*
> — OpenAI, Harness Engineering (2026)

2026년 초, OpenAI는 단 3명의 엔지니어가 AI 에이전트를 활용해 100만 줄의 프로덕션 코드베이스를 구축했다고 발표했다. 수동으로 작성된 소스코드는 없었다. 1,500개의 풀 리퀘스트 전부를 AI 에이전트가 열고 관리했다.

이 결과를 만들어낸 방법론이 **하네스 엔지니어링(Harness Engineering)**이다.

이 시스템은 그 원리를 실제 개발 워크플로에 구현한다. **사람은 설계와 판단**에 집중하고, **AI 에이전트 팀이 실행과 검증**을 담당한다.

---

### 기존 방식의 한계

AI 코딩 도구는 빠른 프로토타이핑에는 유용하지만, 프로젝트가 커질수록 구조적인 문제가 드러난다.

- **맥락 유실과 재현성의 부재** — 대화 기반 작업은 히스토리가 흩어지고, 왜 그렇게 결정했는지 추적할 수 없다. 같은 결과를 다시 만들어내기도 어렵다.
- **자기 검증의 구조적 한계** — 코드를 작성한 AI가 같은 맥락에서 스스로 리뷰하면 자기 변호에 빠지기 쉽다. 독립적인 검증 단계가 없으면 오류가 그대로 통과된다.
- **사람이 병목이 되는 마이크로매니징** — 매 단계마다 사람이 직접 지시하고 확인해야 하므로 인지 부하가 급격히 늘어난다. 결국 사람이 전체 흐름의 병목 지점이 된다.

이 세 문제는 AI 도구의 문제가 아니다. **에이전트를 둘러싼 구조, 즉 하네스의 부재**에서 비롯된다.

---

### 하네스 엔지니어링이란

*Harness*는 마부가 말을 제어하는 마구(馬具)에서 온 말이다. 강력한 엔진(AI 모델)이 있어도, 그것을 올바른 방향으로 이끌고 안전하게 제어하는 구조가 없으면 쓸 수가 없다. 하네스 엔지니어링은 그 제어 구조를 설계하는 일이다.

OpenAI는 앞서 언급 된 글에서 하네스를 다섯 가지 축으로 나누어서 설명했다.

| 요소 | 역할 |
|---|---|
| **Context Engineering** | AI가 판단하는 데 필요한 정보를 체계적으로 설계·제공한다 |
| **Scaffolding** | AI의 행동 방식과 워크플로를 머신-리더블한 형태로 인코딩한다 |
| **Feedback Loops** | AI가 결과를 받아 스스로 반복·개선할 수 있는 구조를 만든다 |
| **Architectural Constraints** | 시스템이 지켜야 할 구조적 규칙을 기계적으로 강제한다 |
| **Garbage Collection** | 에이전트가 생성한 임시 산출물을 정리·관리한다 |

이 중 가장 핵심은 앞의 세 가지다. **Scaffolding이 전체 구조의 기반**을 이루고, Context Engineering이 품질의 천장을 결정하며, Feedback Loops가 자율적 개선을 가능하게 한다.

---

### 이 아키텍처가 해결하는 방법

이 시스템은 두 개의 루프와 그것을 잇는 오케스트레이션 레이어로 구성된다.

#### 큰 루프: Spec → Task → ADR *(Context Engineering)*

모든 작업은 **Spec**에서 시작한다. "왜 이것을 만드는가"를 먼저 문서로 정의하고, 그것을 AI가 실행할 수 있는 단위 **Task(Issue)**로 쪼갠다. Spec이 단일 진실 원천(SSOT)이다.

작업이 진행되면서 Spec에 없던 판단이 필요할 때마다 **ADR**로 기록한다. ADR은 에이전트의 판단을 기록한 문서로 에이전트이 장기 기억 역할을 한다.

ADR마다 후속 이슈가 의무적으로 연결된다. 에이전트가 판단을 내리는 순간 문서화가 시작되고, 후속 이슈가 `closed`될 때 그 결정은 `Confirmed` 상태로 확정된다. Spec에 없던 결정이 생길 때마다 이 사이클이 자동으로 돌아가기 때문에, 코드베이스가 진화할수록 문서도 함께 최신화된다. 문서 업데이트를 별도 작업으로 스케줄링할 필요가 없다.

결과적으로 "왜 그렇게 했는가"를 언제든 추적할 수 있는 체계가 만들어진다.

또한 Spec에서 분해된 Task들은 이슈 의존성 그래프로 연결된다. A가 완료돼야 B를 시작할 수 있는 관계가 명시되면, 의존성이 없는 Task들은 **충돌 없이 병렬로 실행**할 수 있다. 에이전트를 늘려도 순서 충돌이 생기지 않는다.


#### 작은 루프: 구현 → 스펙 리뷰 → 퀄리티 리뷰 *(Feedback Loops + Context Engineering + Architectural Constraints + Garbage Collection)*

Task 하나를 처리할 때 조정자는 세 단계를 각각 **별도 서브에이전트에 위임**한다.

1. **구현 서브에이전트** — 코드를 작성한다
2. **스펙 리뷰 서브에이전트** — Spec의 의도와 맞게 구현됐는지 검증한다
3. **퀄리티 리뷰 서브에이전트** — 코드 자체의 완성도를 검토한다

각 서브에이전트는 **격리된 컨텍스트 윈도우**에서 실행된다. 구현 과정에서 쌓인 맥락과 판단이 리뷰 에이전트에 흘러들어가지 않는다. 같은 코드를 처음 보는 시선으로 검토하기 때문에, 구현 에이전트가 무의식적으로 정당화하는 자기검증 편향이 구조적으로 차단된다.

문제가 발견되면 재작업 → 재리뷰 루프가 자동으로 돌아간다. 사람 손에 닿기 전에 이미 두 번의 독립 검증을 거친다.

#### 오케스트레이션: 두 루프를 잇는 스킬 *(Scaffolding)*

큰 루프(프로젝트 관리)와 작은 루프(태스크 처리) 사이를 연결하는 것이 **SKILL.md** 기반 오케스트레이션이다. 이 방식은 OpenClaw가 채택한 접근이기도 하다.

핵심 강점은 **LLM이 직접 판단한다**는 점이다. 기존 자동화 시스템은 "if A then B"처럼 모든 경우를 미리 코드로 정의해야 한다. 반면 이 시스템은 절차서를 읽은 LLM이 상황을 해석하고 스스로 판단한다. 매뉴얼에 없는 예외 상황도 문맥을 읽어 대응할 수 있다.

어느 Task를 집어야 하는지, 구현이 끝나면 어떤 리뷰를 요청할지, 리뷰 결과에 따라 재작업할지 다음으로 넘어갈지 — 모든 판단을 에이전트가 자율적으로 내린다. 사람이 중간에 개입해 지시할 필요가 없다.

> 스킬 파일 하나를 수정하면, 두 루프에 걸친 전체 동작 방식이 바뀐다. 코드 배포 없이, 텍스트 편집만으로.

---

### 체계가 만드는 차이

결국 이 아키텍처가 한 일은 하나다. **혼돈에 체계를 부여한 것.**

**추적 가능하다.** 모든 결정의 이유가 Spec, Issue, ADR에 남는다. 왜 그렇게 됐는지 언제든 찾을 수 있다.

**관리 가능하다.** 이슈 의존성 그래프가 순서를 강제하고, 스킬이 절차를 대신한다. 사람이 기억하고 지시해야 할 것이 줄어든다.

**신뢰할 수 있다.** 구현과 검증이 격리된 서브에이전트에서 분리 실행된다. 사람 손에 닿기 전에 이미 두 번 독립 검증된 결과물이다.

이 세 성질이 결합되면 전에 없던 일이 가능해진다. **여러 태스크를 병렬로 오케스트레이션하면서도 신뢰성을 유지하고, 인지 부하는 오히려 줄어든다.**

---

### 아키텍처 개요

이 시스템은 **세 평면**으로 구성된다.

```
══ 플랫폼 제어 평면 (IDE) ═══════════════════════════════════
  OpenCode / VSCode
  └─ 에이전트 세션 소유 · 도구 호출 · 사람의 관측·개입 창구

══ 인지 오케스트레이션 평면 (Skills) ════════════════════════
  Superpowers 스킬 (시스템 공통)
  └─ 서브에이전트 파견 · 컨텍스트 격리 · 리뷰 루프
  사용자 정의 스킬 (프로젝트별)
  └─ SKILL.md 절차서 · 에이전트가 온디맨드 로드 → 판단·실행

══ 프로젝트 제어 평면 (Sudocode) ════════════════════════════
  이슈 상태: open → in_progress → needs_review → closed
  Spec · Task · ADR — SSOT 관리 · 이슈 간 의존성 그래프
```

**플랫폼 제어 평면**은 에이전트가 실행되는 환경 자체다. OpenCode나 VSCode 같은 IDE가 터미널 세션을 소유하고 도구를 호출한다. 사람이 별도로 Gateway를 만들 필요 없이, 이 평면이 에이전트와 사람 사이의 관측·개입 창구를 제공한다. 유사시 사람이 개입하는 Human-in-the-loop 기능을 수행할 수 있다.

**인지 오케스트레이션 평면**은 이 시스템의 Scaffolding 구현체다. Superpowers 스킬이 서브에이전트 파견과 컨텍스트 격리를 담당하고, 프로젝트별 SKILL.md가 워크플로 절차를 정의한다. 에이전트의 작업 방식을 정의하며 위 아래의 두 레이어를 잇는 역할을 한다.

**프로젝트 제어 평면**은 Context Engineering의 구현체다. Sudocode가 Spec·Task·ADR을 관리하며, 에이전트가 언제든 "왜 그렇게 했는가"를 조회할 수 있는 장기 기억 역할을 한다. 이슈 간 의존성 그래프로 작업 순서를 자동으로 강제한다.

### 조합의 아키텍처

이 시스템은 새로운 도구를 만들지 않는다. OpenCode, Sudocode, SKILL.md 방식 모두 이미 존재하던 검증된 도구와 패턴이다.

이 시스템이 한 것은 그것들을 **하네스 엔지니어링 원칙에 따라 체계적으로 결합**한 것이다. 각 도구의 유지보수는 각 도구 팀에 위임하고, 이 시스템은 결합 방식, 즉 아키텍처만 소유한다.

> 바퀴를 새로 만들 필요는 없다. 바퀴들을 올바른 순서로, 올바른 방향으로 연결하는 설계도가 가치다.

### 워크플로 요약

이 문서가 제안하는 워크플로는 5단계 파이프라인으로 구성된다.

1. **Spec 작성** — 사람이 요구사항과 설계 의도를 문서로 정의한다.
2. **Roadmap 분해** — Spec을 기반으로 실행 가능한 태스크 단위로 쪼갠다. 어떤 순서로 무엇부터 할지는 Sudocode가 알아서 정리한다.
3. **자동 실행** — AI 에이전트 팀이 구현과 검증을 자동으로 수행한다.
4. **ADR** — 에이전트가 스펙에 명시되지 않은 판단을 내릴 때마다 그 이유를 문서로 남긴다. 나중에 왜 그렇게 했는지 추적할 수 있다.
5. **사람 리뷰** — 사람은 결과물만 확인하고, 승인 또는 피드백을 준다.
6. **반복** — 승인 후 머지되면 에이전트가 자동으로 다음 이슈를 집어 3번으로 돌아간다.


### 사람의 역할 (3가지만)

1. **Spec 작성**: 도메인 요구사항, 스키마, 설계 의도 정의
2. **Roadmap 관리**: 태스크 분해, 우선순위, 의존성 정의
3. **PR 리뷰**: AI가 만든 결과물의 품질 판단

나머지(태스크 선택, 실행 순서 결정, Issue 생성, 브랜치, 구현, 테스트, 상태 추적)는 자동화한다.

## 2. 사용 도구

도구는 세 아키텍처 평면에 따라 분류된다.

---

### 플랫폼 제어 평면 (IDE)

에이전트가 실행되는 환경 자체다.

#### OpenCode / Claude Code

에이전트 세션을 소유하는 플랫폼이다. 터미널 세션을 소유하고 MCP 도구 호출을 처리하며, 사람과 에이전트가 공유하는 단일 UI 창구를 제공한다. 별도의 Gateway를 구현할 필요가 없다.

- **세션 소유** — 조정자 에이전트가 시작부터 종료까지 하나의 세션으로 실행된다
- **도구 호출** — git, bash, 파일 읽기/쓰기, MCP 서버 호출 등 모든 도구 접근을 제공한다
- **실시간 관측** — 서브에이전트가 무엇을 하는지 UI에서 실시간으로 확인할 수 있다. 조정자가 파견한 서브에이전트의 작업도 같은 화면에서 보인다
- **Human-in-the-loop** — 사람이 언제든 개입해 방향을 수정하거나 승인할 수 있다

#### API 키

에이전트가 언어 모델을 호출하기 위한 인증 정보다. OpenCode 설정에서 관리한다. Claude (기본), OpenAI, Gemini 등 멀티 모델을 지원한다.

---

### 인지 오케스트레이션 평면 (Skills)

에이전트의 행동 방식을 정의하는 레이어다. 코드가 아니라 SKILL.md 마크다운으로 정의된다.

#### Superpowers 스킬 (시스템 공통)

여러 프로젝트에서 공통으로 쓰는 글로벌 스킬 모음이다.

**`using-git-worktrees` — 작업 디렉토리 격리**

이슈별로 독립된 git worktree를 생성한다. 서로 다른 이슈를 동시에 진행해도 브랜치 간 충돌이 생기지 않는다.

동작 방식:
1. `.worktrees/` 디렉토리 존재 여부 확인 → 없으면 CLAUDE.md 확인 → 없으면 사용자 질문
2. `git check-ignore`로 해당 디렉토리가 gitignore에 등록됐는지 검증 (미등록 시 자동으로 .gitignore에 추가)
3. `git worktree add`로 워크트리 생성 및 새 브랜치 체크아웃
4. 의존성 설치 + 베이스라인 테스트 실행 → 실패 시 보고

**`dispatching-parallel-agents` — 서브에이전트 병렬 파견**

독립적인 작업 도메인별로 에이전트를 동시 파견한다. 각 서브에이전트는 신선한 컨텍스트 윈도우에서 시작되기 때문에 조정자나 다른 에이전트의 판단이 흘러들어가지 않는다.

사용 조건:
- 2개 이상의 독립 작업이 공유 상태 없이 병렬로 실행 가능할 때
- 공유 파일을 동시에 편집하는 경우에는 사용하지 않는다

#### 사용자 정의 스킬 (프로젝트별)

이 프로젝트의 워크플로를 정의하는 스킬이다. 에이전트가 SKILL.md를 읽고 판단해 실행한다.

---

**`/run-issue` — 이슈 하나를 open에서 needs_review까지**

조정자가 이슈 하나의 전체 라이프사이클을 처리한다.

이슈 선택 로직:
1. `sudocode-mcp_ready` 호출 → 의존성이 해소된 이슈 목록 수신
2. 접두어 우선순위: `ADR-YYMMDD-HHMM` 접두어를 `DEV-###`보다 먼저 선택
3. 같은 접두어 내에서는 번호가 작은 이슈 우선

실행 단계:
```
이슈 선택 → sudocode-mcp_show_issue → 상태 in_progress
→ git worktree 생성
→ [서브에이전트] 구현
→ [서브에이전트] 스펙 준수 리뷰
→ [서브에이전트] 코드 품질 리뷰
→ (문제 발견 시: [서브에이전트] 재작업 → 재리뷰 반복)
→ ADR + 후속이슈 확인
→ 상태 needs_review
→ self-retrospective (단계 이탈 여부 자기 검증)
```

모호성 처리:
- **고영향·불가역** (스코프 변경, 보안 리스크, 데이터 손실 가능성): 실행 중단 → 사용자 문의
- **저영향·가역** (구현 세부사항, 기본값 선택 등): ADR 작성 + 후속 이슈 등록 후 계속 진행

핵심 제약:
- 모든 구현·리뷰·수정은 반드시 서브에이전트를 통해 실행 (조정자 직접 코드 작성 금지)
- 선택한 이슈 스코프 밖의 변경 허용하지 않음

---

**`/run-adr` — ADR 후속 이슈를 유효성 검증 후 구현**

ADR 후속 이슈는 일반 이슈보다 엄격한 절차를 거친다. 구현 전에 ADR 자체가 유효한지 먼저 검증한다.

이슈 선택:
- `ADR-YYMMDD-HHMM` 접두어 전용
- 타임스탬프 기준 가장 오래된 이슈 우선 (결정이 오래 방치될수록 리스크 증가)

ADR 유효성 검토 (구현 전 필수, 두 서브에이전트 동시 파견):
- **서브에이전트 A — 외부 정합성**: specs, 기존 코드, 관련 설정과 결정이 충돌하는지 검토
- **서브에이전트 B — 내부 논리**: 대안 검토 충분성, 기각 사유 적절성, 다른 ADR과의 충돌 여부
- 둘 중 하나라도 INVALID → 이슈 closed, 실행 완전 중단
- 둘 다 VALID → git worktree 생성 후 구현 진행
- 완료 시 이슈 `needs_review` + ADR Status → `Confirmed`

---

**`/issue_approve` — 완료된 작업 승인·머지·정리**

사람이 로컬 리뷰 후 승인할 때 사용한다. 커밋부터 이슈 종결까지 자동으로 처리한다.

워크트리 감지 순서:
1. 현재 세션에서 선언된 이슈 ID와 일치하는 브랜치 (예: `i-81e1-dev-054`)
2. 가장 최근 커밋 타임스탬프
3. 둘 다 불명확하면 사용자에게 선택 요청 (자동선택 시 이유 보고)

실행 순서 (변경 불가):
1. 워크트리 감지
2. 변경사항 스테이징 + 커밋 (시크릿 파일 제외)
3. `git merge --no-ff` into dev → 워크트리 삭제 → 브랜치 삭제 ← 브랜치가 워크트리에 체크아웃 중이므로 워크트리 제거가 먼저
4. Sudocode 이슈 `closed` 처리
5. 처리 내역 한국어로 보고

머지 충돌 발생 시:
- `git merge --abort`로 즉시 복구
- 충돌 파일 목록을 사용자에게 보고
- 워크트리 삭제·브랜치 삭제·이슈 종결 없이 완전 중단

---

**`/create-adr` — 아키텍처 결정 문서화**

스펙에 없는 중요한 판단을 내릴 때 그 이유를 기록한다.

ADR 작성 트리거:
- 기존 `.specs/`와 다른 설계 결정
- 여러 대안 중 하나를 선택했고 트레이드오프를 기록해야 할 때
- 하위 호환성을 깨는 인터페이스 변경
- 보안·성능에 직접 영향을 주는 결정

식별자 및 파일명:
```bash
TZ=Asia/Seoul date '+%Y%m%d-%H%M'  # KST 타임스탬프
# 파일: docs/adr/YYMMDD-HHMM-<kebab-title>.md
```

ADR 구조:

| 섹션 | 내용 |
|------|------|
| **Created At** | `YYYY-MM-DD HH:mm KST` 형식의 작성 시각 |
| **Status** | `PendingReview` (초기) → `Confirmed` (run-adr 완료 후) |
| **Context** | 이 결정이 필요해진 배경과 제약조건 |
| **Decision** | 선택한 접근법을 **단 한 문장**으로 선언 |
| **Rationale** | 고려한 대안 목록, 기각 이유, 최종 선택의 트레이드오프 |

후속 의무: ADR마다 Sudocode 후속 이슈를 생성하고 현재 이슈에 링크해야 한다. 이슈 없는 ADR은 미완성이다.

---

### 프로젝트 제어 평면 (Sudocode)

에이전트의 장기 기억과 작업 상태를 관리하는 레이어다.

#### Sudocode MCP

Spec·Issue·ADR을 관리하는 MCP 서버다. 에이전트와 사람이 같은 이슈 목록을 공유한다.

**이슈 상태 머신:**

```
open → in_progress → needs_review → closed
```

- `open`: 실행 대기 중 (의존성이 있으면 ready 목록에 올라오지 않음)
- `in_progress`: 에이전트가 작업 중
- `needs_review`: 에이전트 완료, 사람 검토 대기
- `closed`: 승인·머지 완료

**의존성 그래프:**

이슈 간 `blocks` 관계를 설정한다. A가 B를 막고 있으면, A가 `closed`가 될 때까지 B는 `ready` 목록에 올라오지 않는다. 의존성이 없는 이슈들은 자동으로 병렬 실행 대상이 된다.

**`sudocode-mcp_ready`:**

의존성이 모두 해소된 이슈만 반환한다. 에이전트는 이 목록에서만 다음 작업을 선택하므로, 순서를 어기는 실수를 구조적으로 방지한다.

**핵심 MCP 도구:**

| 도구 | 역할 |
|------|------|
| `sudocode-mcp_ready` | 의존성 해소된 이슈 목록 조회 |
| `sudocode-mcp_show_issue` | 이슈 상세 조회 (title, description, 관계) |
| `sudocode-mcp_upsert_issue` | 이슈 생성 또는 상태·내용 업데이트 |
| `sudocode-mcp_link` | 이슈 간 관계 설정 (blocks, implements, depends-on 등) |
| `sudocode-mcp_list_specs` | Spec 목록 조회 |
| `sudocode-mcp_show_spec` | Spec 상세 조회 |
| `sudocode-mcp_add_feedback` | Spec 또는 이슈에 피드백 기록 |

#### ADR 파일 시스템

`docs/adr/` 디렉토리에 저장되는 마크다운 문서들이다. Spec·Issue와 함께 SSOT의 세 번째 구성 요소다.

**ADR Status 생명주기:**
- `PendingReview`: `create-adr` 스킬로 생성 직후 (검증 전)
- `Confirmed`: `run-adr` 스킬이 유효성 검토 통과 후 구현 완료 시 자동 설정

`Confirmed` 상태 ADR은 이후 에이전트가 동일 결정을 재검토하지 않아도 되는 확정된 아키텍처 지식이다.

---

## 3. 워크플로우

### 오케스트레이션 구조

에이전트의 행동을 코드로 하드코딩하지 않는다. SKILL.md 마크다운 절차서로 정의하고, 에이전트가 이 파일을 읽고 스스로 판단해 실행한다.

**1차 레이어 (Skills 패턴)** — 조정자 에이전트가 SKILL.md를 온디맨드로 로드해 워크플로 전체를 실행한다. 사람이 `/run-issue`를 호출하면 조정자가 이슈 선택부터 검증 완료까지 스스로 처리한다.

**2차 레이어 (Subagents 패턴)** — 조정자는 구현과 리뷰를 직접 하지 않는다. 신선한 컨텍스트의 서브에이전트에 위임한다. 구현한 에이전트와 리뷰하는 에이전트가 분리되기 때문에 자기검증 편향이 사라진다.

두 레이어의 결합이 이 시스템의 핵심이다.

### 다이어그램

```
══ 플랫폼 제어 평면 (OpenCode IDE) ══════════════════════
  에이전트 세션 소유 · 도구 호출 · 사람의 관측·개입 창구
══════════════════════════════════════════════════════════

[사람] Spec 작성
  ↓
[사람] Roadmap 분해 → Sudocode 이슈 등록 (의존성 그래프)
  ↓
── 1차 레이어 (Skills) ──────────────────────────────────
  [조정자] /run-issue SKILL.md 로드
    ├─ sudocode-mcp_ready → 이슈 선택 (ADR 우선, 작은 번호 우선)
    ├─ git worktree로 작업 디렉토리 격리
    ├─ 이슈 상태 → in_progress
    │
── 2차 레이어 (Subagents) ───────────────────────────────
    │  ├─ [서브에이전트] 구현
    │  ├─ [서브에이전트] 스펙 준수 리뷰
    │  ├─ [서브에이전트] 코드 품질 리뷰
    │  │   └─ (문제 발견 시 재작업 → 재리뷰)
─────────────────────────────────────────────────────────
    │
    ├─ (결정이 필요한 경우)
    │   ├─ 고영향·불가역 → 실행 중단 → 사용자 문의
    │   └─ 저영향·가역  → ADR 작성 + 후속이슈 등록 → 계속
    └─ 이슈 상태 → needs_review

══ 프로젝트 제어 평면 (Sudocode) ════════════════════════
  이슈 상태: open → in_progress → needs_review → closed
  Spec · Task · ADR — SSOT 관리 · 의존성 그래프
══════════════════════════════════════════════════════════

[사람] 로컬 리뷰 (OpenCode UI에서 관측·확인)
  ↓
[사람] /issue_approve → 머지 → 워크트리 정리 → 이슈 closed
  ↓
[에이전트] sudocode-mcp_ready → 다음 이슈로 반복
```

### 워크플로우 상세

#### 1단계: Spec 작성 (사람 + 에이전트)

에이전트가 "왜 이걸 만드는가"를 알 수 있어야 올바른 판단을 내릴 수 있다.

Spec에는 이런 내용이 담긴다:
- 도메인 요구사항과 제약조건
- 데이터 스키마나 인터페이스 정의
- 설계 의도 — 무엇을 원하는지보다 **왜** 그것을 원하는지

Spec이 없으면 에이전트는 판단 근거 없이 작업한다. 결과물이 의도와 달라도 알 방법이 없다.

저장 위치: `.specs/<feature-name>.md` / Sudocode에 `sudocode-mcp_upsert_spec`으로 등록하면 에이전트가 MCP를 통해 조회 가능하다.

#### 2단계: Roadmap 분해 (사람 + 에이전트)

Spec을 에이전트가 실행 가능한 단위로 쪼갠다. 각 이슈는 한 번의 작업 세션으로 끝낼 수 있는 범위다.

이슈 크기 기준:
- 너무 크면: 에이전트가 한 세션에 처리 못하거나 스코프 이탈 가능성 증가
- 너무 작으면: 오케스트레이션 오버헤드(worktree 생성, PR 등)가 가치보다 커짐
- 적정 기준: 구현 서브에이전트가 처리할 수 있는 응집된 기능 단위

의존성 설정 원칙:
- A가 생성한 스키마·인터페이스를 B가 사용하면 A `blocks` B 설정
- 실제로 순서가 필요한 관계만 설정 (과도한 의존성은 병렬성을 해침)
- 의존성이 없는 이슈들은 자동으로 동시 실행 가능

태스크를 잘게 쪼갤수록 생기는 이점:
- **스코프 이탈 방지** — 이슈 범위가 좁을수록 구현 서브에이전트가 의도하지 않은 영역까지 건드리는 일이 줄어든다.
- **리뷰 정확도 향상** — 스펙 리뷰·품질 리뷰 서브에이전트가 검증해야 할 범위가 좁아져, 빠뜨리는 항목이 적어진다.
- **장애 격리** — 하나의 이슈가 실패해도 의존성이 없는 다른 이슈들은 계속 진행된다.
- **병렬 실행 확대** — 의존성 없는 이슈가 많아질수록 동시 실행 가능한 에이전트 수가 늘어난다.

이슈 접두어 규칙:
- `DEV-###`: 일반 구현 이슈
- `ADR-YYMMDD-HHMM`: ADR 후속 이슈 (run-adr가 처리)

#### 3단계: 자동 실행 (에이전트)

`/run-issue` 스킬 하나로 이슈 하나의 전체 라이프사이클을 처리한다.

**1차 레이어 — 조정자의 역할:**
- git worktree 생성 (작업 디렉토리 격리, 메인 브랜치와 분리)
- 서브에이전트 파견 및 결과 수집
- 모호한 판단이 생기면 ADR 작성 또는 사용자 문의

**2차 레이어 — 서브에이전트의 역할:**
- 구현 서브에이전트: 코드 작성 (신선한 컨텍스트)
- 스펙 리뷰 서브에이전트: Spec의 의도와 맞게 구현됐는지 독립 검증
- 품질 리뷰 서브에이전트: 코드 자체의 완성도 검토
- 문제 발견 시 재작업 서브에이전트 재파견 → 재리뷰 반복

조정자는 직접 코드를 작성하지 않는다. 위임하고, 결과를 받아 다음 단계를 결정한다.

**결정이 생길 때 처리 방식:**

| 결정 유형 | 처리 |
|---|---|
| 고영향·불가역 (스코프 변경, 보안, 데이터 손실) | 실행 중단 → 사용자 문의 |
| 저영향·가역 (구현 세부사항, 기본값 선택 등) | ADR 작성 + 후속이슈 등록 → 계속 진행 |

#### 4단계: 로컬 리뷰 (사람)

에이전트가 이미 독립 검증 루프를 거쳤다. 사람은 OpenCode UI에서 전체 흐름을 확인하고, 결과물이 의도에 맞는지만 판단하면 된다.

사람이 확인해야 하는 것:
- 결과물이 Spec의 의도에 맞는가
- 에이전트가 기록한 ADR이 납득 가능한가

사람이 확인하지 않아도 되는 것:
- 코드 스타일 (품질 리뷰 서브에이전트가 이미 검토)
- 스펙 준수 여부 (스펙 리뷰 서브에이전트가 이미 검토)

#### 5단계: 승인 (사람)

`/issue_approve` 스킬이 머지부터 정리까지 자동으로 처리한다.

내부 처리 순서:
1. 피처 브랜치의 워크트리 자동 감지
2. 변경사항 스테이징 + 커밋
3. `dev` 브랜치에 `--no-ff` 머지 → 워크트리 제거 → 브랜치 삭제
4. Sudocode 이슈 `closed`
5. 처리 내역 한국어로 보고

머지 충돌이 발생하면 자동 중단하고 충돌 파일 목록을 보고한다. 사람이 수동으로 해결한 뒤 다시 실행한다.

---

## 4. 문서 아티팩트

이 시스템의 SSOT(Single Source of Truth)는 세 종류의 문서 아티팩트로 구성된다.

---

### Spec

요구사항·설계 의도·인터페이스 계약을 담는 문서다. 에이전트가 구현 판단의 근거로 삼는 1차 컨텍스트다.

**저장 위치**: `.specs/<feature-name>.md`

**등록**: `sudocode-mcp_upsert_spec` — Spec ID를 부여하며, 에이전트가 MCP를 통해 조회 가능하다.

**필수 구성 요소:**

| 항목 | 내용 |
|------|------|
| **설계 의도** | 이 기능이 해결하는 문제와 그 이유 |
| **제약조건** | 성능·보안·호환성 등 반드시 지켜야 할 경계 |
| **인터페이스 정의** | 데이터 스키마, API 계약, 외부 연동 규격 |
| **비기능 요구사항** | 응답 시간, 처리량, 오류 허용 범위 |
| **비포함 항목** | 이 Spec이 다루지 않는 것 — 명시적 제외 |

**에이전트 접근**: 이슈 실행 시 서브에이전트가 `sudocode-mcp_show_spec`으로 Spec을 조회한다. Spec이 없으면 에이전트는 판단 근거 없이 작업하며, 결과물이 의도와 달라도 감지할 수단이 없다.

**이슈 연결**: 이슈는 `implements` 링크로 Spec에 연결된다. Sudocode DAG가 이 관계를 추적한다.

---

### Issue (Task)

에이전트가 실행하는 작업 단위다. 하나의 이슈는 하나의 에이전트 세션 안에서 완결될 수 있는 응집된 기능 범위를 가진다.

**저장 위치**: `.sudocode/issues.jsonl` (Sudocode MCP가 관리)

**접두어 규칙:**

| 접두어 | 처리 스킬 | 의미 |
|--------|-----------|------|
| `DEV-###` | `/run-issue` | 일반 구현 이슈 |
| `ADR-YYMMDD-HHMM` | `/run-adr` | ADR 유효성 검증 + 구현 이슈 |

**상태 머신**: `open → in_progress → needs_review → closed`

**의존성 그래프**: `blocks` 관계로 이슈 간 실행 순서를 강제한다. A가 B를 block하면, A가 `closed`가 될 때까지 B는 `sudocode-mcp_ready` 목록에 올라오지 않는다.

**크기 기준:**
- 구현 서브에이전트가 한 번의 컨텍스트 안에서 처리 가능한 응집된 기능 단위
- 너무 크면 스코프 이탈 위험 증가; 너무 작으면 worktree 생성·PR 등 오케스트레이션 오버헤드가 구현 가치를 초과

---

### ADR (Architecture Decision Record)

Spec에 명시되지 않은 설계 결정을 기록하는 문서다. 에이전트가 구현 중 판단을 내릴 때 생성하며, `/run-adr`이 유효성을 검증하고 구현한다.

**저장 위치**: `docs/adr/YYMMDD-HHMM-<kebab-title>.md`

**식별자**:
```bash
TZ=Asia/Seoul date '+%Y%m%d-%H%M'  # KST 타임스탬프
```

**필수 섹션:**

| 섹션 | 형식 | 내용 |
|------|------|------|
| **Created At** | `YY-MM-DD HH:mm KST` | 작성 시각 |
| **Status** | `PendingReview` \| `Confirmed` | 검증 상태 |
| **Context** | 자유 텍스트 | 결정이 필요해진 배경과 제약조건 |
| **Decision** | **단 한 문장** | 선택한 접근법 선언 |
| **Rationale** | 목록형 | 고려한 대안, 기각 이유, 트레이드오프 |

**Status 생명주기:**
- `PendingReview`: `create-adr` 스킬로 생성 직후
- `Confirmed`: `/run-adr`이 유효성 검토 통과 후 구현 완료 시 자동 설정

**ADR 작성 트리거:**
- 기존 `.specs/`와 다른 설계 결정
- 여러 대안 중 하나를 선택하고 트레이드오프를 기록해야 할 때
- 하위 호환성을 깨는 인터페이스 변경
- 보안·성능에 직접 영향을 주는 결정

**후속 이슈 의무**: ADR마다 `ADR-YYMMDD-HHMM` 접두어의 Sudocode 이슈를 생성하고 현재 이슈에 링크한다. 후속 이슈 없는 ADR은 미완성이다.

---

## 5. 운영 가이드

### 일반 이슈 실행

```
사람: /run-issue
에이전트: sudocode-mcp_ready → 이슈 선택 → 작업 시작 보고
```

에이전트가 어떤 이슈를 선택했고 왜 그 이슈를 선택했는지 보고한다. 이 단계에서 이슈 선택이 적절한지 확인하고, 필요하면 개입할 수 있다.

### ADR 이슈 처리

```
사람: /run-adr
에이전트: ADR-YYYYMMDD-HHMM 이슈 선택 → 두 서브에이전트로 ADR 유효성 검토
         → VALID이면 구현 진행 / INVALID이면 이슈 closed + 사유 보고
```

INVALID 반환 시: ADR 문서를 수정한 뒤 다시 `/run-adr`을 실행한다.

### 승인 흐름

```
사람: /issue_approve
에이전트: 워크트리 감지 → 커밋 → 머지 → 정리 → 이슈 closed 보고
```

머지 충돌 발생 시: 에이전트가 충돌 파일 목록과 함께 중단한다. 수동으로 충돌을 해결한 뒤 다시 실행한다.

### 병렬 실행

의존성이 없는 이슈들을 여러 터미널에서 동시에 실행할 수 있다.

- 각 에이전트는 별도 git worktree에서 작업하므로 파일 충돌이 없다
- 이슈 상태가 `in_progress`로 설정되는 순간 다른 에이전트가 같은 이슈를 선택하지 않는다
- 머지는 하나씩 순서대로 처리한다 (`/issue_approve` 반복)

### 트러블슈팅

| 상황 | 원인 | 해결 |
|------|------|------|
| `sudocode-mcp_ready`가 빈 목록 반환 | 모든 이슈에 미해소 의존성 | 막고 있는 이슈를 먼저 처리하거나 의존성 재검토 |
| ADR 유효성 검토 INVALID | ADR의 Context/Decision/Rationale 중 문제 | 보고된 이유를 확인하고 ADR 수정 후 재시도 |
| 머지 충돌 | 다른 브랜치와 동일 파일 수정 | 충돌 파일 수동 해결 → `git add` → `/issue_approve` 재실행 |
| 스펙 리뷰 서브에이전트가 계속 실패 | Spec 의도와 구현 방향 불일치 | Spec 수정 또는 이슈 description 보강 후 재실행 |
| 워크트리 자동 감지 실패 | 여러 피처 브랜치가 존재 | 에이전트가 후보 목록을 제시, 사람이 선택 |

